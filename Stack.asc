
String StackDataDelimiter;
String StackDataFormat;
export StackDataFormat; // allow extensions from other scripts
String StackDataCopyFormat;

StackDataType GetType(this StackData*) {
  if (this.Length < (StackDataFormat.Length - 1)) return eStackDataInvalid;
  String type = this.Substring(0, StackDataFormat.Length - 1);
  int i = type.IndexOf(":");
  if (i == -1) return eStackDataInvalid;
  char c = type.Chars[i + 1];
  if (type != String.Format(StackDataFormat, c)) return eStackDataInvalid;
  return c;
}

int GetAsInt(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if (((type != eStackDataInt) && (eStackStrictTypes)) || (type == eStackDataStack)) return 0;
  return data.AsInt;
}

float GetAsFloat(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if (((type != eStackDataFloat) && (eStackStrictTypes)) || (type == eStackDataStack)) return 0.0;
  return data.AsFloat;
}

String GetAsString(this StackData*) {
  StackDataType type = this.GetType();
  if (((type != eStackDataString) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return this.Substring(StackDataFormat.Length - 1, this.Length);
}

Character* GetAsCharacter(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if ((data.AsInt < 0) || (data.AsInt >= Game.CharacterCount) ||
  ((type != eStackDataCharacter) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return character[data.AsInt];
}

InventoryItem* GetAsInventoryItem(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if ((data.AsInt <= 0) || (data.AsInt > Game.InventoryItemCount) ||
  ((type != eStackDataInventoryItem) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return inventory[data.AsInt];
}

GUI* GetAsGUI(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if ((data.AsInt < 0) || (data.AsInt >= Game.GUICount) ||
  ((type != eStackDataGUI) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return gui[data.AsInt];
}

GUIControl* GetAsGUIControl(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if ((data.AsInt < 0) || (data.AsInt >= (Game.GUICount * AGS_MAX_CONTROLS_PER_GUI))) return null;
  int guiID = data.AsInt / AGS_MAX_CONTROLS_PER_GUI;
  int controlID = data.AsInt % AGS_MAX_CONTROLS_PER_GUI;
  if ((guiID >= Game.GUICount) || (controlID >= AGS_MAX_CONTROLS_PER_GUI) ||
  ((type != eStackDataGUIControl) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return gui[guiID].Controls[controlID];
}

static StackData Stack::IntToData(int theInt) {
  String type = String.Format(StackDataFormat, eStackDataInt);
  return String.Format("%s%d", type, theInt);
}

static StackData Stack::FloatToData(float theFloat) {
  String type = String.Format(StackDataFormat, eStackDataFloat);
  return String.Format("%s%f", type, theFloat);
}

static StackData Stack::StringToData(String theString) {
  String type = String.Format(StackDataFormat, eStackDataString);
  return type.Append(theString);
}

static StackData Stack::CharacterToData(Character *theCharacter) {
  if (theCharacter == null) return null;
  String type = String.Format(StackDataFormat, eStackDataCharacter);
  return String.Format("%s%d", type, theCharacter.ID);
}

static StackData Stack::InventoryItemToData(InventoryItem *theItem) {
  if (theItem == null) return null;
  String type = String.Format(StackDataFormat, eStackDataInventoryItem);
  return String.Format("%s%d", type, theItem.ID);
}

static StackData Stack::GUIToData(GUI *theGUI) {
  if (theGUI == null) return null;
  String type = String.Format(StackDataFormat, eStackDataGUI);
  return String.Format("%s%d", type, theGUI.ID);
}

static StackData Stack::GUIControlToData(GUIControl *theControl) {
  if (theControl == null) return null;
  String type = String.Format(StackDataFormat, eStackDataGUIControl);
  return String.Format("%s%d", type, ((theControl.OwningGUI.ID * AGS_MAX_CONTROLS_PER_GUI) + theControl.ID));
}

StackData MergeArray(this Stack*, StackData array[]) {
  if (array == null) return null;
  String glue = StackDataDelimiter;
  String buffer = "";
  int i = 0;
  int size = this.ItemCount;
  while (i < size) {
    buffer = buffer.Append(array[i]);
    if (i < (size - 1)) buffer = buffer.Append(glue);
    i++;
  }
  return buffer;
}

StackData[] GetItemsArray(this Stack*) {
  if ((this.Data == null) || (!this.ItemCount)) return null;
  String items[] = new String[this.ItemCount];
  String buffer = this.Data;
  String format = StackDataFormat.Substring(0, StackDataFormat.IndexOf(":") + 1);
  int i = buffer.IndexOf(format);
  int j = 0;
  while ((i != -1) && (j < this.ItemCount)) {
    StackDataType type = buffer.Chars[format.Length];
    if (type == eStackDataStack) {
      String temp = buffer.Substring(StackDataFormat.Length - 1, buffer.Length);
      String stamp = temp.Substring(0, StackDataCopyFormat.Length + 14); // format + 16 byte key - %s
      temp = temp.Substring(stamp.Length, temp.Length);
      i = temp.IndexOf(stamp);
      if (i != -1) items[j] = buffer.Truncate(i + (StackDataFormat.Length - 1) + (stamp.Length * 2));
      else items[j] = buffer;
      if ((i != -1) && ((i + (StackDataFormat.Length - 1) + (stamp.Length * 2) + StackDataDelimiter.Length) < buffer.Length)) {
        buffer = buffer.Substring(i + (StackDataFormat.Length - 1) + (stamp.Length * 2) + StackDataDelimiter.Length, buffer.Length);
      }
      else buffer = null;
      j++;
    }
    else {
      i = buffer.IndexOf(StackDataDelimiter);
      if (i != -1) items[j] = buffer.Substring(0, i);
      else items[j] = buffer;
      if ((i != -1) && ((i + StackDataDelimiter.Length) < buffer.Length)) {
        buffer = buffer.Substring(i + StackDataDelimiter.Length, buffer.Length);
      }
      else buffer = null;
      j++;
    }
    if (buffer != null) i = buffer.IndexOf(format);
    else i = -1;
  }
  return items;
}

#ifndef StringPlus_VERSION
String[] SplitByString(this String*, String otherString) {
  String s[];
  int i = this.IndexOf(otherString);
  if ((String.IsNullOrEmpty(otherString)) || (i == -1)) {
    s = new String[2];
    s[0] = "1";
    s[1] = this;
    return s;
  }
  s = new String[this.Length + 1];
  String buffer = this;
  int lineCount = 0;
  while (i != -1) {
    lineCount++;
    s[lineCount] = buffer.Substring(0, i);
    i += otherString.Length;
    if (i < buffer.Length) {
      buffer = buffer.Substring(i, buffer.Length);
      i = buffer.IndexOf(otherString);
    }
    else i = -1;
  }
  lineCount++;
  s[lineCount] = buffer;
  String t[] = new String[lineCount + 1];
  i = 1;
  while (i <= lineCount) {
    t[i] = s[i];
    i++;
  }
  t[0] = String.Format("%d", lineCount);
  return t;
}

String StringMergeArray(String array[], String glue) {
  if ((array == null) || (String.IsNullOrEmpty(array[0])) || (array[0].AsInt <= 0)) return null;
  if (glue == null) glue = "";
  String buffer = "";
  int i = 1;
  int size = array[0].AsInt;
  while (i <= size) {
    buffer = buffer.Append(array[i]);
    if (i < size) buffer = buffer.Append(glue);
    i++;
  }
  return buffer;
}
#endif

StackData BuildKey(this Stack*) { // returns a 128-bit (16-byte) key for Stack::Copy
  String key = "";
  int i = 0;
  while (i < 16) {
    char c = 0;
    int j = 7;
    while (j >= 0) { // build-a-byte
      DateTime *now = DateTime.Now;
      bool bit = (Random(now.RawTime) % 2); // returns either 1 or 0
      c += (bit << j); // then we shift that bit into place
      j--;
    }
    if (c) {
      key = key.AppendChar(c);
      i++;
    }
  }
  return key;
}

StackData MaskStacksForCopy(this Stack*) {
  // regenerates any existing Stack keys (see BuildKey) when pushing a Stack object (copy) onto this stack
  // prevents issues with the data structure
  if (String.IsNullOrEmpty(this.Data)) return this.Data;
  String s[] = this.Data.SplitByString(StackDataCopyFormat.Substring(0, 18)); // split the data by the stacks within it
  if (s[0].AsInt == 1) return this.Data;
  int size = s[0].AsInt;
  // structure of S will be:
  //   1: **STACKDATA:k** - the data type, a stack
  //   2: XXXXXXXXXXXXXXXX**DATA - the 128-bit (16-byte) key originally assigned here followed by the stack's data
  //   3: XXXXXXXXXXXXXXXX** - the same key
  // the rest of StackDataCopyFormat is removed by SplitByString
  int i = 2; // start at the first available key
  while (i < size) {
    String key = this.BuildKey(); // grab a new key
    s[i] = key.Append(s[i].Substring(16, s[i].Length)); // replace both instances
    s[i + 1] = key.Append(s[i + 1].Substring(16, s[i + 1].Length));
    i += 3; // increasing by 3 sets I to the next "2" index in the structure
  }
  return StringMergeArray(s, StackDataCopyFormat.Substring(0, 18));
}

bool Stack::Push(StackData data, int index) {
  if ((index == SCR_NO_VALUE) || (index > this.ItemCount)) index = this.ItemCount;
  if ((index < 0) || (data == null)) return false;
  if (String.IsNullOrEmpty(this.Data)) {
    this.Data = data;
    this.ItemCount++;
    return true;
  }
  if (data.GetType() == eStackDataStack) this.Data = this.MaskStacksForCopy(); // prevent issues if pushing the same stack multiple times
  String items[] = this.GetItemsArray();
  int size = this.ItemCount;
  if (index < size) items[index] = data;
  this.Data = this.MergeArray(items);
  if (index >= size) {
    this.Data = this.Data.Append(StackDataDelimiter.Append(data));
    this.ItemCount++;
  }
  return true;
}

StackData Stack::Pop(bool remove, int index) {
  if (index == SCR_NO_VALUE) {
    if (this.PopType == eStackPopFirstInFirstOut) index = 0;
    else if (this.PopType == eStackPopFirstInLastOut) index = (this.ItemCount - 1);
    else if (this.PopType == eStackPopRandom) index = Random(this.ItemCount - 1);
  }
  if ((index < 0) || (index >= this.ItemCount) || (!this.ItemCount) ||
  (String.IsNullOrEmpty(this.Data))) return null;
  String items[] = this.GetItemsArray();
  int size = this.ItemCount;
  String data = items[index];
  if (remove) {
    this.ItemCount--;
    if ((!this.ItemCount) || (size == 1)) {
      this.Data = null;
      items = null; // prevent AGS 3.1.2 bug - Object not in managed pool.
      return data;
    }
    String buffer[] = new String[this.ItemCount];
    int i = 0;
    while (i < this.ItemCount) {
      if (i < index) buffer[i] = items[i];
      else buffer[i] = items[i + 1];
      i++;
    }
    items = buffer;
  }
  this.Data = this.MergeArray(items);
  items = null; // prevent AGS 3.1.2 bug - Object not in managed pool.
  return data;
}

void Stack::Clear() {
  this.Data = null;
  this.ItemCount = 0;
}

bool Stack::IsEmpty() {
  return (!this.ItemCount);
}

StackData Stack::Copy() {
  String type = String.Format(StackDataFormat, eStackDataStack);
  String key = this.BuildKey();
  String stamp = String.Format(StackDataCopyFormat, key);
  String data = this.Data;
  if (data == null) data = "";
  String s = type.Append(stamp.Append(String.Format("%d,%d,", this.ItemCount, this.PopType)));
  return s.Append(data.Append(stamp));
}

bool Stack::LoadFromStack(StackData otherStack) {
  if ((otherStack == null) || (otherStack.GetType() != eStackDataStack)) return false;
  String data = otherStack.Substring(StackDataFormat.Length - 1, otherStack.Length);
  String stamp = data.Substring(0, StackDataCopyFormat.Length + 14); // format + 16 byte key - %s
  data = data.Substring(stamp.Length, data.Length);
  data = data.Truncate(data.IndexOf(stamp));
  String buffer = data.Substring(0, data.IndexOf(","));
  this.ItemCount = buffer.AsInt;
  data = data.Substring(buffer.Length + 1, data.Length);
  buffer = data.Substring(0, data.IndexOf(","));
  this.PopType = buffer.AsInt;
  this.Data = data.Substring(buffer.Length + 1, data.Length);
  return true;
}

bool WriteStack(this File*, StackData stackCopy) {
  if ((this.Error) || (stackCopy == null) || (stackCopy.GetType() != eStackDataStack)) return false;
  this.WriteString(stackCopy);
  return (!this.Error);
}

StackData ReadStackBack(this File*) {
  if ((this.Error) || (this.EOF)) AbortGame("File::ReadStackBack: File was not written by File::WriteStack.");
  String data = this.ReadStringBack();
  if ((data == null) || (data.GetType() != eStackDataStack) || (this.Error)) AbortGame("File::ReadStackBack: File was not written by File::WriteStack.");
  return data;
}

void Stack::LoadFromFile(File *theFile) {
  if ((theFile == null) || (theFile.Error) || (theFile.EOF)) AbortGame("Stack::LoadFromFile: File was not written by File::WriteStack.");
  this.LoadFromStack(theFile.ReadStackBack());
}

function game_start() {
  StackDataDelimiter = "**STACKDATA**";
  StackDataFormat = "**STACKDATA:%c**";
  StackDataCopyFormat = "**STACKDATA STACK:%s**";
}
