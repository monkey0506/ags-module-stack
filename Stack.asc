
String StackDataDelimiter;
String StackDataFormat;
export StackDataFormat; // allow extensions from other scripts
String StackDataCopyFormat;

StackDataType GetType(this StackData*) {
  if (this.Length < (StackDataFormat.Length - 1)) return eStackDataInvalid;
  StackData type = this.Substring(0, StackDataFormat.Length - 1);
  int i = type.IndexOf(":");
  if (i == -1) return eStackDataInvalid;
  char c = type.Chars[i + 1];
  if (type != String.Format(StackDataFormat, c)) return eStackDataInvalid;
  return c;
}

int GetAsInt(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if (((type != eStackDataInt) && (eStackStrictTypes)) || (type == eStackDataStack)) return 0;
  return data.AsInt;
}

float GetAsFloat(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if (((type != eStackDataFloat) && (eStackStrictTypes)) || (type == eStackDataStack)) return 0.0;
  return data.AsFloat;
}

String GetAsString(this StackData*) {
  StackDataType type = this.GetType();
  if (((type != eStackDataString) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return this.Substring(StackDataFormat.Length - 1, this.Length);
}

Character* GetAsCharacter(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if ((data.AsInt < 0) || (data.AsInt >= Game.CharacterCount) ||
  ((type != eStackDataCharacter) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return character[data.AsInt];
}

InventoryItem* GetAsInventoryItem(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if ((data.AsInt <= 0) || (data.AsInt > Game.InventoryItemCount) ||
  ((type != eStackDataInventoryItem) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return inventory[data.AsInt];
}

GUI* GetAsGUI(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if ((data.AsInt < 0) || (data.AsInt >= Game.GUICount) ||
  ((type != eStackDataGUI) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return gui[data.AsInt];
}

GUIControl* GetAsGUIControl(this StackData*) {
  StackData data = this.Substring(StackDataFormat.Length - 1, this.Length);
  StackDataType type = data.GetType();
  if ((data.AsInt < 0) || (data.AsInt >= (Game.GUICount * AGS_MAX_CONTROLS_PER_GUI))) return null;
  int guiID = data.AsInt / AGS_MAX_CONTROLS_PER_GUI;
  int controlID = data.AsInt % AGS_MAX_CONTROLS_PER_GUI;
  if ((guiID >= Game.GUICount) || (controlID >= AGS_MAX_CONTROLS_PER_GUI) ||
  ((type != eStackDataGUIControl) && (eStackStrictTypes)) || (type == eStackDataStack)) return null;
  return gui[guiID].Controls[controlID];
}

static StackData Stack::IntToData(int theInt) {
  StackData type = StackData.Format(StackDataFormat, eStackDataInt);
  return StackData.Format("%s%d", type, theInt);
}

static StackData Stack::FloatToData(float theFloat) {
  StackData type = StackData.Format(StackDataFormat, eStackDataFloat);
  return StackData.Format("%s%f", type, theFloat);
}

static StackData Stack::StringToData(String theString) {
  StackData type = StackData.Format(StackDataFormat, eStackDataString);
  return type.Append(theString);
}

static StackData Stack::CharacterToData(Character *theCharacter) {
  if (theCharacter == null) return null;
  StackData type = StackData.Format(StackDataFormat, eStackDataCharacter);
  return StackData.Format("%s%d", type, theCharacter.ID);
}

static StackData Stack::InventoryItemToData(InventoryItem *theItem) {
  if (theItem == null) return null;
  StackData type = StackData.Format(StackDataFormat, eStackDataInventoryItem);
  return StackData.Format("%s%d", type, theItem.ID);
}

static StackData Stack::GUIToData(GUI *theGUI) {
  if (theGUI == null) return null;
  StackData type = StackData.Format(StackDataFormat, eStackDataGUI);
  return StackData.Format("%s%d", type, theGUI.ID);
}

static StackData Stack::GUIControlToData(GUIControl *theControl) {
  if (theControl == null) return null;
  StackData type = StackData.Format(StackDataFormat, eStackDataGUIControl);
  return StackData.Format("%s%d", type, ((theControl.OwningGUI.ID * AGS_MAX_CONTROLS_PER_GUI) + theControl.ID));
}

StackData MergeArray(this Stack*, StackData array[]) {
  if (array == null) return null;
  StackData glue = StackDataDelimiter;
  StackData buffer = "";
  int i = 0;
  int size = this.ItemCount;
  while (i < size) {
    buffer = buffer.Append(array[i]);
    if (i < (size - 1)) buffer = buffer.Append(glue);
    i++;
  }
  return buffer;
}

StackData[] GetItemsArray(this Stack*) {
  if (this.Data == null) return null;
  StackData items[] = new StackData[this.ItemCount];
  StackData buffer = this.Data;
  String format = StackDataFormat.Substring(0, StackDataFormat.IndexOf(":") + 1);
  int i = buffer.IndexOf(format);
  int j = 0;
  while ((i != -1) && (j < this.ItemCount)) {
    StackDataType type = buffer.Chars[format.Length];
    if (type == eStackDataStack) {
      StackData temp = buffer.Substring(StackDataFormat.Length - 1, buffer.Length);
      StackData stamp = temp.Substring(0, StackDataCopyFormat.Length + 14); // format + 16 byte key - %s
      temp = temp.Substring(stamp.Length, temp.Length);
      i = temp.IndexOf(stamp);
      if (i != -1) items[j] = buffer.Truncate(i + (StackDataFormat.Length - 1) + (stamp.Length * 2));
      else items[j] = buffer;
      if ((i != -1) && ((i + (StackDataFormat.Length - 1) + (stamp.Length * 2) + StackDataDelimiter.Length) < buffer.Length)) {
        buffer = buffer.Substring(i + (StackDataFormat.Length - 1) + (stamp.Length * 2) + StackDataDelimiter.Length, buffer.Length);
      }
      else buffer = null;
      j++;
    }
    else {
      i = buffer.IndexOf(StackDataDelimiter);
      if (i != -1) items[j] = buffer.Substring(0, i);
      else items[j] = buffer;
      if ((i != -1) && ((i + StackDataDelimiter.Length) < buffer.Length)) {
        buffer = buffer.Substring(i + StackDataDelimiter.Length, buffer.Length);
      }
      else buffer = null;
      j++;
    }
    if (buffer != null) i = buffer.IndexOf(format);
    else i = -1;
  }
  return items;
}

bool Stack::Push(StackData data, int index) {
  if ((index == SCR_NO_VALUE) || (index > this.ItemCount)) index = this.ItemCount;
  if ((index < 0) || (data == null)) return false;
  if (StackData.IsNullOrEmpty(this.Data)) {
    this.Data = data;
    this.ItemCount++;
    return true;
  }
  StackData items[] = this.GetItemsArray();
  int size = this.ItemCount;
  if (index < size) items[index] = data;
  this.Data = this.MergeArray(items);
  if (index >= size) {
    this.Data = this.Data.Append(StackDataDelimiter.Append(data));
    this.ItemCount++;
  }
  return true;
}

StackData Stack::Pop(bool remove, int index) {
  if (index == SCR_NO_VALUE) {
    if (this.PopType == eStackPopFirstInFirstOut) index = 0;
    else if (this.PopType == eStackPopFirstInLastOut) index = (this.ItemCount - 1);
    else if (this.PopType == eStackPopRandom) index = Random(this.ItemCount - 1);
  }
  if ((index < 0) || (index >= this.ItemCount) || (!this.ItemCount) ||
  (StackData.IsNullOrEmpty(this.Data))) return null;
  StackData items[] = this.GetItemsArray();
  int size = this.ItemCount;
  StackData data = items[index];
  if (remove) {
    this.ItemCount--;
    if ((!this.ItemCount) || (size == 1)) {
      this.Data = null;
      items = null; // prevent AGS 3.1.2 bug - Object not in managed pool.
      return data;
    }
    StackData buffer[] = new StackData[this.ItemCount];
    int i = 0;
    while (i < this.ItemCount) {
      if (i < index) buffer[i] = items[i];
      else buffer[i] = items[i + 1];
      i++;
    }
    items = buffer;
  }
  this.Data = this.MergeArray(items);
  items = null; // prevent AGS 3.1.2 bug - Object not in managed pool.
  return data;
}

void Stack::Clear() {
  this.Data = null;
  this.ItemCount = 0;
}

bool Stack::IsEmpty() {
  return (!this.ItemCount);
}

StackData BuildKey(this Stack*) { // returns a 128-bit (16-byte) key for Stack::Copy
  StackData key = "";
  int i = 0;
  while (i < 16) {
    char c = 0;
    int j = 7;
    while (j >= 0) { // build-a-byte
      DateTime *now = DateTime.Now;
      bool bit = (Random(now.RawTime) % 2); // returns either 1 or 0
      c += (bit << j); // then we shift that bit into place
      j--;
    }
    if (c) {
      key = key.AppendChar(c);
      i++;
    }
  }
  return key;
}

StackData Stack::Copy() {
  StackData type = StackData.Format(StackDataFormat, eStackDataStack);
  StackData key = this.BuildKey();
  StackData stamp = StackData.Format(StackDataCopyFormat, key);
  StackData data = this.Data;
  if (data == null) data = "";
  return StackData.Format("%s%s%d,%d,%s%s", type, stamp, this.ItemCount, this.PopType, data, stamp);
}

bool Stack::LoadFromStack(StackData otherStack) {
  if ((otherStack == null) || (otherStack.GetType() != eStackDataStack)) return false;
  StackData data = otherStack.Substring(StackDataFormat.Length - 1, otherStack.Length);
  StackData stamp = data.Substring(0, StackDataCopyFormat.Length + 14); // format + 16 byte key - %s
  data = data.Substring(stamp.Length, data.Length);
  data = data.Truncate(data.IndexOf(stamp));
  StackData buffer = data.Substring(0, data.IndexOf(","));
  this.ItemCount = buffer.AsInt;
  data = data.Substring(buffer.Length + 1, data.Length);
  buffer = data.Substring(0, data.IndexOf(","));
  this.PopType = buffer.AsInt;
  this.Data = data.Substring(buffer.Length + 1, data.Length);
  return true;
}

bool WriteStack(this File*, StackData stackCopy) {
  if ((this.Error) || (stackCopy == null) || (stackCopy.GetType() != eStackDataStack)) return false;
  this.WriteString(stackCopy);
  return (!this.Error);
}

StackData ReadStackBack(this File*) {
  if ((this.Error) || (this.EOF)) AbortGame("File::ReadStackBack: File was not written by File::WriteStack.");
  StackData data = this.ReadStringBack();
  if ((data == null) || (data.GetType() != eStackDataStack) || (this.Error)) AbortGame("File::ReadStackBack: File was not written by File::WriteStack.");
  return data;
}

void Stack::LoadFromFile(File *theFile) {
  if ((theFile == null) || (theFile.Error) || (theFile.EOF)) AbortGame("Stack::LoadFromFile: File was not written by File::WriteStack.");
  this.LoadFromStack(theFile.ReadStackBack());
}

function game_start() {
  StackDataDelimiter = "**STACKDATA**";
  StackDataFormat = "**STACKDATA:%c**";
  StackDataCopyFormat = "**STACKDATA STACK:%s**";
}
